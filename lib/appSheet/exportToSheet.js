"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportToSheet = void 0;
const google_spreadsheet_1 = require("google-spreadsheet");
const alphanumeric_encoder_1 = __importDefault(require("alphanumeric-encoder"));
const exportToSheet = async (datas, sheetId) => {
    console.log("exportToSheet");
    // be be replaced by auth.json data
    const { GOOGLE_SERVICE_ACCOUNT_EMAIL, GOOGLE_PRIVATE_KEY, EXPORT_SHEET_ID } = process.env;
    // let rawdatas = fs.readFileSync("jobseasons-oauth.json", "utf8");
    // let datas = JSON.parse(rawdatas);
    if (GOOGLE_SERVICE_ACCOUNT_EMAIL &&
        GOOGLE_PRIVATE_KEY &&
        EXPORT_SHEET_ID &&
        datas.length > 0) {
        const doc = new google_spreadsheet_1.GoogleSpreadsheet(EXPORT_SHEET_ID);
        const keys = Object.keys(datas[0]);
        const newIds = datas.map((data) => data.id);
        await doc.useServiceAccountAuth({
            // env var values are copied from service account credentials generated by google
            // see "Authentication" section in docs for more info
            client_email: GOOGLE_SERVICE_ACCOUNT_EMAIL,
            private_key: GOOGLE_PRIVATE_KEY,
        });
        await doc.loadInfo(); // loads document properties and worksheets
        const sheet = doc.sheetsById[sheetId];
        const rows = await sheet.getRows();
        // console.log("rows", rows);
        const previousDatas = rows.map((row) => {
            const previousData = {};
            keys.forEach((key) => (previousData[key] = row[key]));
            return previousData;
        });
        const previousDatasIds = previousDatas.map((data) => data.id);
        const newDatas = datas.filter((data) => !previousDatasIds.includes(data.id));
        const nbNew = newDatas.length;
        const filteredPreviousDatas = previousDatas.filter((data) => !newIds.includes(data.id));
        // sheet.clearRows();
        // const allDatas = [...filteredPreviousDatas, ...datas].sort(
        const allDatas = newDatas.sort((dataA, dataB) => {
            if (dataA.id > dataB.id) {
                return -1;
            }
            if (dataA.id < dataB.id) {
                return 1;
            }
            return 0;
        });
        if (allDatas.length) {
            let nbCols = Object.keys(allDatas[0]).length;
            const encoder = new alphanumeric_encoder_1.default();
            const encodedCol = encoder.encode(nbCols);
            sheet.insertDimension("ROWS", { startIndex: 1, endIndex: nbNew + 1 }, false);
            await sheet.loadCells(`A2:${encodedCol}${nbNew + 1}`);
            allDatas.map((data, dataIndex) => {
                Object.keys(data).map((col, colIndex) => {
                    const cell = sheet.getCell(dataIndex + 1, colIndex);
                    if (cell)
                        cell.value = data[col] || "";
                });
            });
            await sheet.saveUpdatedCells();
        }
        return nbNew;
    }
};
exports.exportToSheet = exportToSheet;
